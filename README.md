# Инструкция к запуску

1.  Скачайте репозиторий.
2.  Скачайте .env.local, который вы можете получить, перейдя по этой [ссылке](https://drive.google.com/file/d/1kdb84MYEQR5SX9uNe0mPba2hStM6rVnr/view?usp=sharing), и перетащите его в основную папку проекта (на одном уровне с package.json).
3.  Убедитесь, что у вас установлена актуальная версия Node.js.
4.  Запустите команду `npm install` для установки зависимостей.
5.  После установки зависимостей, запустите команду `npm run dev`.
6.  Проект должен быть доступен на `localhost:3000`.

# Запуск тестов

1.  Запустите проект на `localhost:3000`, как указано в пред. инструкции.
2.  Откройте еще одну _отдельную_ вкладку терминала.
3.  Запустите команду `npm run e2e`.
4.  Должно открыться отдельное окно, в котором нужно выбрать файл теста.
5.  В отдельном окне запустится Chrome, который автоматически проведет указанные тесты.

# Ответы на вопросы

### Q1

### Расскажите, чем, на ваш взгляд, отличается хорошее клиентское приложение от плохого с точки зрения пользователя, менеджера проекта, дизайнера, верстальщика, серверного программиста.

**Пользователь**.  
Хорошее приложение ведет себя так, как от него ожидают. Клиент не ждет, что окно, всплывшее после нажатия на кнопку, нельзя будет закрыть или что видео запуститься только через пару секунд после клика. Это очевидные моменты, но есть и более тонкие: клиент не ожидает длинных неуместных анимаций, дополнительных модальных окон и форм, дополнительных шагов в привычных действиях и т.д.
Приложение должно быть простым и приятным для использования.

**Менеджер проекта**  
Приложение отвечает всем предъявленным к нему требованиям.
У приложения чистый код и продуманная архитектура, поэтому нынешним сотрудникам легко его модифицировать, а новым — легко вникнуть и начать работать.
Приложение легко тестировать или его значительная часть покрыта тестами — чтобы находить ошибки быстрее и планировать их исправление наперед.

**Дизайнер**  
Приложение должно быть удобным, отвечая современным тенденциям дизайна. Удобство клиента у приложения стоит на первом месте, поэтому ненужные анимации или сбивающие с толку элементы сразу удаляются. Взаимодействие с приложением должно быть естественным. Пользователь как можно меньше должен думать, что случится при взаимодействии с компонентами — это должно быть очевидно.

**Верстальщик**  
Верстка хорошего приложения разделена на компоненты, которые почти (в идеале — совсем) изолированны. Эти компоненты легко модифицируются, не нарушая работу друг друга. Их не больно перемещать и менять местами. Хорошая верстка в итоге создает ощущение, будто играешься с конструктором — все очень стабильно и независимо.

**Серверного программиста**  
Если честно, я не знаю, что важно для бэкэндера. Мой уровень работы с бэкэндом состоит лишь из получения нужных мне JSON-ов.

Здравый смысл предполагает, что клиентское приложение должно хорошо масштабироваться при увеличении нагрузки с сервера. Оно предусматривает обработку большого количества данных, не нарушая работу интерфейса. С помощью Service Worker-ов или асинхронности, например.

### Q2

### Опишите основные особенности разработки крупных многостраничных сайтов, функциональность которых может меняться в процессе реализации и поддержки. Расскажите о своем опыте работы над подобными сайтами: какие подходы, инструменты и технологии вы применяли на практике, с какими проблемами сталкивались и как их решали.

У меня нет опыта разработки крупных и (или) многостраничных сайтов. В первом вопросе я описал моменты, которые важны для каждого приложения, это здравый смысл. Кроме них, единственная специфичная проблема, с которой я сталкивался лично — обмен данных между страницами. Она обычно решается использованием ContextAPI, Redux, MobX или другого решения, которое позволяет создать глобальный state. React Router также поддерживает создание общих для нескольких роутов данных, но код быстро становится нечитаемым.

Я предпочитаю пользоваться именно URL, а для объемных данных использовать Redux или переносить как можно больше данных в компоненты повыше и передавать их в props.

### Q3

### При разработке интерфейсов с использованием компонентной архитектуры часто используются термины Presentational Сomponents и Сontainer Сomponents. Что означают данные термины? Зачем нужно такое разделение, какие у него есть плюсы и минусы?

Container component — это компонент, который получает данные, а потом рендерит соответствующий ему компонент, передавая ему эти данные через props. Эти контейнеры обычно используются, как источники данных для presentational компонентов — поэтому они могут, например, передавать HTTP-запросы, запускать экшены в Redux. Из-за этого они часто имеют свой state.

**Компоненты контейнеры не имеют отношения к дизайну** — поэтому у них обычно почти нет стилей, а DOM обычно состоит из одного DIV.

Presentational components — это компоненты, которые обычно получают готовые данные и занимаются их отображением. У них редко бывает свой state, они редко изменяют свои данные, не делают запросов и не диспатчат Redux-экшены. Свои данные они обычно получают в props от компонентов-контейнеров. Стилей и DOM в них, разумеется, на порядок больше.

Такое разделение обычно нужно для сохранения масштабирования и более чистого кода/архитектуры. Разделив компоненты на две роли, за ними гораздо легче следить и их легче редактировать, чем если бы все было понапихано в один компонент. Грубо говоря — separation of concerns.

Минусы возникают, когда такой подход применяется в маленьких приложениях, у которых никогда и не стояла проблема с архитектурой или разделением ответственности. Когда проект состоит из 3-4 компонентов, разделять их на две группы не принесет ничего, кроме раздутого количества файлов.

### Q4

### Как устроено наследование в JS? Расскажите о своем опыте реализации JS наследования без использования фреймворков.

В JS у каждого объекта есть свойство 'Prototype'. Это значение или равно `null` или ссылается на другой объект, который и называется "прототипом".
**Если мы пытаемся вызвать у объекта значение, которого у него не задано, он будет это значение искать в своем прототипе**

Например:
`const living_being = { breathes: true, has_blood: true }`
`const human = { __proto__: living_being, amount_of_legs: 2}`

Если мы попробовать вернуть `human.breathes`, нам вернет `true`, потому что у объекта `human` есть **прототип** `living_being` в котором есть ключ `breathes`;
Таким образом можно объединять цепочкой любое количество объектов, главное чтобы это не было циклом.

В JS также есть классы, которые могут наследовать друг друга с помощью команды `extends`.
Это используется в React, например: `class Component extends React`

Я никогда не использовал наследования в коммерческих приложениях.

### Q5

### Какие библиотеки можно использовать для написания тестов end-to-end во фронтенде? Расскажите о своем опыте тестирования веб-приложений.

На коммерческих проектах автоматизированных тестов я никогда не писал. Я много слышал про Jest, но никогда его не пробовал.

Познакомился с Cypress во время выполнения этого тестового задания, это мой первый опыт автоматизированных тестов вообще.

### Q6

### Вам нужно реализовать форму для отправки данных на сервер, состоящую из нескольких шагов. В вашем распоряжении дизайн формы и статичная верстка, в которой не показано, как форма должна работать в динамике. Подробного описания, как должны вести себя различные поля в зависимости от действий пользователя, в требованиях к проекту нет. Ваши действия?

Сначала просто спрошу, должны ли эти требования вообще быть. Иногда бывает, что их просто забыли указать.

Обязательно пройдусь по указанным требованиям, позабочусь о том, чтобы они были выполнены до того, как я приступлю к след. проблеме. После этого попробую представить, как динамика должна себя вести, опишу это на словах и покажу дизайнеру/репортеру задачи. Если у него нет замечаний — делаю. В идеальном случае можно еще показывать промежуточные варианты, чтобы не потерять времени зря.

### Q7

### Расскажите, какие инструменты помогают вам экономить время в процессе написания, проверки и отладки кода.

Для быстрого форматирования кода я использую Prettier. Ну и конечно расширения для VSCode, список которых часто пополняется.

Для быстрой справки по CSS заглядываю на [CSSReference.io](https://cssreference.io/), по JS — MDN и Javascript.info. Для библиотек естественно использую их документацию. Часто в доках можно найти уже готовые решения имеющихся проблем.

### Q8

### Какие ресурсы вы используете для развития в профессиональной сфере? Приведите несколько конкретных примеров (сайты, блоги и так далее).

### Какие ещё области знаний, кроме тех, что непосредственно относятся к работе, вам интересны?

Львиную долю информации я получаю через YouTube. На YouTube часто смотрю такие каналы как Traversy Media, JavaScript Mastery, freeCodeCamp.org. И если меня заинтересует какая-либо тема или технология, начинаю гуглить и искать углубленную информацию.

Кроме фронтэнда, я еще иногда изучаю Веб-Дизайн.

### Q9

### Расскажите немного о себе

Я начал заниматься веб разработкой где-то год назад. Сначала освоил HTML и CSS, потом постепенно перешел на JS, однако тогда я не стал долго на нем задерживаться и кинулся учить PHP и MySQL. Наверстал свой первый сайт-портфолио, с адаптивным дизайном и с формой с проверкой ввода на JS и отправкой писем на PHP. Все это время я пользовался только англоязычными ресурсами, просто потому что их было больше.

Потом я решил сделать себе блог с нуля, для этого начал учить Laravel. И примерно в то же время я узнал о разнице между многостраничными сайтами и SPA, и идея одностраничного приложения с приятным асинхронным интерфейсом меня привлекла. Я много слышал про встроенную совместимость у Laravel-а с Vue JS, поэтому я начал изучать именно этот фреймворк.

В конце концов я оставил идею с блогом, и постепенно стал фокусироваться больше на фронтенде. Вскоре, поняв какие технологии пользуются наибольшей популярностью, я решил перейти на React. Переделал свой [портфолио](https://amirshammasov.com), используя его, а также несколько проектов, ссылки на которые вы можете найти на моем сайте. Еще немного изучал Three JS, поскольку 3D объекты в сайтах набирают все большую популярность, сделал простенький [сайт](https://buisness-training.netlify.app) с 3D-моделью.

В данный момент работаю над сайтом для малого бизнеса и создаю шаблоны для сайтов. Пока у меня нет опыта работы в компании, однако я надеюсь исправить это в скором времени.
